#include <iostream>
#include <fstream>
#include <string>
#ifndef TARGET_OS_MAC
#include <cstring>
#endif
#include <array>
#include <vector>
#include <unistd.h>
#include <list>
// how users inputs blank value and how we print it out.
#define BLANK_VAL 'B'
/* this program solves a slide puzzle, for instance given in microsoft rewards.
 * The puzzle has a rectangular grid with one blank space.  The remaining
 * spaces are part of a scrambled picture.  The goal is to move one tile at a
 * time into the blank space in the puzzle so that the picture is as expected.
 * So, lets say a starting configuration of a 3x3 puzzle is 
 * 8 5 2
 * 3  4 Blank
 * 5 6 1 
 *  the goal is to make a series of moves such that the result is
 * 1 2 3 
 * 4 5 6
 * 7 8 Blank.
 * Each move is a swap of Blank for some adjacent vertical or horizontal move,
 * so, in the above example, 2 or 4 can be swapped for Blank.  If two is
 * swapped
 * swapped,  you get 8 5 Blank
 * 		     3 4 2
 * 		     5 6 1
 *
 * The program takes two arguments, -x and -y which specified an x and y
 * dimension.  Then, it takes the starting configuration with "B" for blank
 * so for the above example, slidePuzzle -x 3 -y 3 8 5 2 3 4 B 5 6 1
 * 
 * The program works by adding a starting configuration to a list.
 * the list is traversed and for each configuration in the list, new
 * configurations are generated by adding legal moves based on where the B is
 * in the puzzle.  These configurations are added to a second list.  Each legal
 * configuration is saved in a data structure, so when a configuration is
 *  found, if moves have not been added yet, it's added to a second list.
 * when the first list is done, the next interation is for the second list of
 * what we found new the last time. This continues until the final puzzle
 * Configuration  is found, or no more configurations are left.
 * Note that each iteration though a list is one more move away from the
 * starting postion, any configuration, including the final configuration is
 * reached for the first time in the smallest number of moves.n  Thus, we can
 * end the first time we find a final configuration.
 */
int yDim=0;
int xDim=0;
// class representing a puzzle coordinate.
class Coord {
	public:
	 int x;
	int y;
	Coord(int x,int y) {
		this->x=x;
		this->y = y;
	}
};


// class representing the static infomration about the puzzle, e.g. the size
// and  what moves are legal given the location of a blank in the puzzle.
// 
class Puzzle {
	public:
	static int xDim;
	static int yDim;
	static int size;
	static std::vector<std::vector<std::list<Coord> > > moves;
	static int blankVal;
	void static initPuzzle(int x,int y) {
		xDim=x;
		yDim=y;
		size=xDim*yDim;
		// there is one 
		blankVal = (x * y) ;
		// now we know the dimensions of moves so we can initialize it.
		moves = std::vector<std::vector<std::list<Coord> > >(x);
		for ( int i=0;i<x;i++) {
			moves[i] = std::vector<std::list<Coord> >(y);
			for ( int j=0;j<y;j++) {
				// if the Blank is not in the first cololm moving right is ok
				if ( j>0 ) {
					moves[i][j].push_back(Coord(i,j-1));
				} 
				// if the blank is not in the last column, moving left is ok
				if ( j != (y-1)  ) {
					moves[i][j].push_back(Coord(i,j+1));
				}
				// if the blank i snot in the first row, you can move up
				if ( i>0 ) {
					moves[i][j].push_back(Coord(i-1,j));
				} 
				// if the blank is not in the last row, you can move down.
				if ( i != (x-1) ) {
					moves[i][j].push_back(Coord(i+1,j));
				}
			}
		}
	}
};
bool Debug = false;

// space for static variables.
int Puzzle::xDim =0;
int Puzzle::yDim =0;
int Puzzle::size ;
int Puzzle::blankVal=0;
std::vector<std::vector<std::list<Coord> > > Puzzle::moves = std::vector<std::vector<std::list<Coord> > >(0);
// final configuration.
class PuzzleConfig *finalConfig = NULL;
bool verbose = true;

// class for a specific puzzle configuration.
// puzzle contents are in a character array.
// which  show how you move from the starting posistion to the ending position.

class PuzzleConfig { 
	public:
	std::vector<std::vector <int> > puzzleContents;
	char *contents;
	std::list<Coord> moveList;
	Coord blank;
	bool final;
	int xSize;
	int ySize;
	static char  *finalContents;
	// the puzzle is solved when it's contents are 1, 2, 3. .. B.
	// B is represented by x*y.
	static void setFinalContents() {
		finalContents = (char *) malloc(Puzzle::size);
		for ( int i=0;i<Puzzle::xDim*Puzzle::yDim-1;i++) { 
			PuzzleConfig::finalContents[i] = (char) i+1;
		}
		PuzzleConfig::finalContents[Puzzle::size-1] = Puzzle::blankVal;
	}

	PuzzleConfig( int x,int y): blank(0,0) {
		this->xSize=x;
		this->ySize=y;
	
		this->final=false;
		contents = (char *) malloc(xSize*ySize);
		this->blank = Coord(0,0);
	}
	~PuzzleConfig() {
		free (contents);
	}
	// copy of puzzleConfig, except blank is swapped for coord
	PuzzleConfig(PuzzleConfig *oPuzzle,Coord move)  :blank(0,0) {
		// copy puzzleContents
		this->final=false;
		this->xSize=oPuzzle->xSize;
		this->ySize=oPuzzle->ySize;
		contents = (char *) malloc(xSize*ySize);
		strncpy(this->contents,oPuzzle->contents,this->xSize * this->ySize);

		// swap blank and move.
		int val = this->getVal(move);
		this->add(val,oPuzzle->blank);
		
		this->setBlank(move);
		// this->print();
		// copy movelist and add a move specified by move.
		std::list<Coord>::iterator it;
		for ( it= oPuzzle->moveList.begin();it != oPuzzle->moveList.end();it++ ) {
			this->moveList.push_back(*it);
		}
		this->moveList.push_back(move);
		
		if ( strncmp(this->contents,PuzzleConfig::finalContents,Puzzle::size ) ==
0 ) {
			this->final = true;
		}
		if ( finalConfig == NULL ) {
			finalConfig = this;
		}
	}
	// update the value at coord with val
	void add(int val,Coord c) {
		this->contents[c.x*this->xSize+c.y] = val;
	}
	int getVal(Coord c) {
		return(this->contents[c.x*this->xSize+c.y]);
	}
	// set the blank for this puzzle.
	void setBlank(Coord c) {
		add(Puzzle::blankVal,c);
		this->blank= c;
	}
	// are both puzzle Configurations the same.
	// Note:  we don't care about the moveList.
	bool compare(PuzzleConfig *otherConfig) {
		if ( strncmp(this->contents, otherConfig->contents,Puzzle::size) == 0 )  {
			return true;
		}
		return false;
	}
	// print the results
	void print( bool detail = true ) {
		for ( int i=0;i<Puzzle::size;i++ ) {
			int val = this->contents[i];
			// std::cout << "Puzzle Val" <<  val << " Index " << i << std::endl;	
			if ( val == Puzzle::blankVal ) {
				std::cout << " " << BLANK_VAL;
			} else {
				std::cout << " " << val;
			}
		}
		std::cout << std::endl;
		if ( detail ) {
			std::cout << " " << this->blank.x << " " << this->blank.y << std::endl;
			std::cout << " " << this->moveList.size()  <<  std::endl;
		}
		
	}
};

char *PuzzleConfig::finalContents = NULL;

// class to represent what configurations we've encountered so far.
// We use a 2D vector of lists of puzzle configurations to store this to reduce
// the  searching required to find a configuration.
// so for each configuration, we search this list in the vector for the value
// at  0 and 1 of the contents
// Thus, if the puzzle has values 8 5 2 ..., we search the vector at [8][5] to
// see if we get a match.

class PuzzleConfigList { 
	std::vector<std::vector <std::list <PuzzleConfig * >  > >  allConfigs;
	// initialize the vectors to lists.
	public:  PuzzleConfigList () {
		// initilaize the vector that holds the configurations.  The vector is blankVal x blankVal 
		allConfigs = std::vector< std::vector<std::list <PuzzleConfig * > > > (Puzzle::blankVal+1 );
		for ( int i=0;i<Puzzle::blankVal+1;i++ ) {
			//std::cout << "Setting allConfigs " << i << " " << Puzzle::blankVal << std::endl;
			allConfigs[i] = std::vector<std::list <PuzzleConfig * > > (Puzzle::blankVal+1 );
			for ( int j=0;j<Puzzle::blankVal+1;j++ ) {
				// std::cout << "Setting allConfigs " << i << " " << j << std::endl;
				allConfigs[i][j]  = std::list< PuzzleConfig *>() ;
	
			}
		}
	}
	// add the configuration to the proper vector.
	void add(PuzzleConfig *config) {
		allConfigs[config->contents[0]][config->contents[1]].push_back(config);
	}
	// search for the configuration.
	PuzzleConfig *search(PuzzleConfig *config ) {
		std::list<PuzzleConfig *>::iterator it;
		std::list<PuzzleConfig *> *list;
		list = &(allConfigs[config->contents[0]][config->contents[1]]);
		for ( it = list->begin();it!=list->end();++it) {
			if ( config->compare(*it) ) {
				return (*it);
			}
		}
		return(NULL);
	}
		
};

void printFinalConfig ( PuzzleConfig * finalConfig,PuzzleConfig *startConfig)
{
	std::list<Coord>::iterator it;
	//found a match
	std::cout << "Solution Found" << std::endl;
	std::cout << "Moves from start " << std::endl;
	int mvCnt=1;
	PuzzleConfig *currentStep = startConfig;
	PuzzleConfig *nextStep ;
	for ( it= finalConfig->moveList.begin();it != finalConfig->moveList.end();it++ ) {
		std::cout << mvCnt++ << " (" << (*it).x+1 << ", " << (*it).y+1<<  ")"  ;
		nextStep=new PuzzleConfig(currentStep,(*it));
		if ( verbose ) {
			nextStep->print(false);
		}
		currentStep=nextStep;
		// the print prints the std::endl;
		// std::cout << std::endl;
	}	
}


// this is the core function here.  We have two lists exploreList and
// addedList.
// to start an iteration of the loop, exploreList contains puzzle
// configurations we haven't processed yet and addedList is empty.
// for each item in exploreList, generate new configurations by taking each of
// the possible moves from that position.  For each such configuration, see if
// it's been found yet.  If found, we don't need to process it further.  We
// either explored it already, or we will explore it in this iteration or we
// will explore it during the next iteration.  Those are the only cases in
// which the configuration would have been encountered already.  if we haven't
// encountered the configuration yet, add it to the added list and to all
// configurations.
// On the next iteration, exploreList will be the addedList and addedList will
// be cleared.
// we are done when we haven't added anything during the pass, so explore list
// on the next iteration is empty.

void explore(PuzzleConfig * config) {
	// the confiigList is every position we've found so far.  Go through
	// list and generate the next moves.  Keep going until we don't add
	// anything else 
	// std::cout << move.x << " " << move.y << std::endl;
	// we use pointers so we can swap easier.
	std::list<PuzzleConfig *> listOne;
	std::list <PuzzleConfig *> listTwo;
	std::list <PuzzleConfig *> *addedList,*exploreList;
	//std::cout << "Call to explore " << std::endl;
	listOne.push_back(config);
	// initialize the pointers
	exploreList=&listOne;
	addedList=&listTwo;
	bool addedConfig=false;
	PuzzleConfig *matchConfig;
	// set up the object to hold what we've encountered so far.
	PuzzleConfigList *allConfigs = new PuzzleConfigList();
	// iterator for explore list
	std::list<PuzzleConfig *>::iterator it;
	int dupConfig =0;
	do {
		if ( Debug ) {
			std::cout << "Starting explore loop "<< exploreList->size() <<  " " << dupConfig << std::endl;
		}
		dupConfig =0;
		for ( it = exploreList->begin();it != exploreList->end();++it) {
			// generate moves for this configuration
			int blankX = (*it)->blank.x;
			int blankY = (*it)->blank.y;
			bool moveAdded = false;
			// iterator for legal moves
			std::list<Coord>::iterator it2;;
			// (*it)->print();
			for ( it2= Puzzle::moves[blankX][blankY].begin();it2 != Puzzle::moves[blankX][blankY].end();it2++ ) {
				// for each legal move, generate the next configurations.
				PuzzleConfig *newPuzzleConfig = new PuzzleConfig((*it),*(it2));
				// have we seen this before.
				if ( (matchConfig = allConfigs->search(newPuzzleConfig)) != NULL  )  {
					// since we've seen this before, delete the objeÃ§t
					delete(newPuzzleConfig);
					dupConfig++;
					// 
				} else {
						moveAdded = true;
						// we found a new configuration so add it to addedList for next iteration
						addedList->push_back(newPuzzleConfig);
						// and add it to everything seen so far
						allConfigs->add(newPuzzleConfig);
						// the first time we find the final  configuration, we've found the
						// the best path
						if ( newPuzzleConfig->final ) {
							printFinalConfig(newPuzzleConfig,config);
							exit(0);
						}
					}
			}
		}
		// now empty the exploreList and switch.
		// on the next iteration of the loop, exploreList is the
		// addedList and addedList is empty
		std::list <PuzzleConfig *> *tempList;
		exploreList->clear();
		tempList = exploreList;
		exploreList = addedList;
		addedList = tempList;
		
		
		
	} while (   exploreList->size() > 0 ) ;
	
}

int main(int argc,char **argv)  {
	const char *optStr="x:y:dv";
	int yDim,xDim;
	int opt;
	while ((opt=getopt(argc,argv,optStr)) != -1 )  {
		switch(opt) {
		case 'y':
			yDim=atoi(optarg);
			break;
		case 'x':
			xDim=atoi(optarg);
			break;
		case 'd':
			Debug=true;
			break;
		case 'v':
			verbose =true;
			break;
		}
	}
	if ( Debug ) {
		std::cout << yDim << " " << xDim << std::endl;
	}
	Puzzle::initPuzzle(xDim,yDim);
	// starting puzzle Configuration.
	PuzzleConfig *startConfig = new PuzzleConfig(xDim,yDim);
	int i = argc;
	int rowDim=0;
	int colDim=0;

	// we need to range check the numbers.  We can each # in the range 1..  x * y -1 and B one time.
	bool gotBlank=false;
	std::vector<bool> gotVal = std::vector<bool>(xDim*yDim);
	for ( int j=0;j<xDim*yDim;j++ ) {
		gotVal[j]=false;
	}
	
	while ( optind < argc ) {
		// std::cout << argv[optind][0] << std::endl;
		if ( rowDim > xDim - 1 ) {
			std::cerr <<  "Too many values for puzzle" << std::endl;
			exit(1);
		}
		if ( argv[optind][0] == BLANK_VAL) {
			startConfig->setBlank(Coord(rowDim,colDim));
			if ( gotBlank) {
				std::cerr << "Blank specified twice" << std::endl;
				exit(1);
			} else {
				gotBlank=true;
			}
		//	std::cout << "Setting blank Value in Puzzle" << std::endl;
		} else {
			int	iVal = atoi(argv[optind]);
			if ( iVal >=  Puzzle::blankVal )  {
				std::cerr << "Value too Large.  Values are 1 to " << Puzzle::blankVal -1 << " plus B"  << std::endl;
				exit(1);
			}
			
			if ( gotVal[iVal] ) {
				std::cerr << iVal << " specified twice" << std::endl;
				exit(1);
			}
			gotVal[iVal] = true;
			startConfig->add(atoi(argv[optind]),Coord(rowDim,colDim));
		}
		// std::cout << "Row " << rowDim << " COL " << colDim << " Value " << atoi(argv[optind]) << std::endl;
		if ( colDim==yDim-1) {
			colDim=0;
			rowDim=rowDim+1;
		} else {
			colDim= colDim+1;
		}

		optind++;
	}
	for ( int j=1;j<xDim*yDim;j++ ) {
		if ( ! gotVal[j] ) {
			std::cerr << j  << " not specified " << std::endl;
			exit(1);;
		}
	}
	if ( ! gotBlank) {
			std::cerr << "B"  << " not specified " << std::endl;
	}
	if ( Debug ) {
		startConfig->print();
	}
	PuzzleConfig::setFinalContents();
	explore(startConfig);
	// if we get here, we did not find a solution
	std::cout << "No Solution Found" << std::endl;
}
